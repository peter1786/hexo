---
title: mysql索引优化原则
tags:
  - mysql
categories:
  - 数据库
toc: false
date: 2018-03-24 20:42:50
---

## 不要过度索引。
我们都知道索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引。

1. 第一种情况是表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引，让查询做全表扫描就好了。至于多少条记录才算多，这个个人有个人的看法，我个人的经验是以2000作为分界线，记录数不超过 2000可以考虑不建索引，超过2000条可以酌情考虑索引。
2. 更新十分频繁字段上不宜建立索引
	更新会变更 B+ 树，重建索引。这个过程是十分消耗数据库性能的。
3. 另一种不建议建索引的情况是索引的选择性较低。所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值：
`count(distinct(列名))/count(*) `
选择性越高的索引价值越大，比例越大我们扫描的记录数越少，唯一键的区分度是1。 一般区分度在80%以上的时候就可以建立索引。
- 对Cardinality的统计是使用采样方式进行估算的，当表的修改数目超过总记录的1/16、或者修改总次数超过20亿次，则会随机选择8个数据页重新统计该值，不过通过ANALYZE TABLE命令可以强制让数据库重新收集相关的统计信息。


## 索引使用的地方
1. where
	最常用到的，不解释
2. order by
	不给order by加索引，就需要mysql server层自己去排序，explain Extra会得到using filesort 当使用排序的空间超过sort_buffer_size的时候，会使用临时表，explain Extra会得到using temporary
3. group by
	group by 操作在没有合适的索引可用的时候，通常先扫描整个表提取数据并创建一个临时表，然后按照group by 指定的列进行排序.在explain中通常可以看到 `using temporary`; `using filesort`
4. join on 
	多表关联时，要保证关联字段上一定有索引
	MySQL内部采用了一种叫做 nested loop join的算法。Nested Loop Join 实际上就是通过驱动表的结果集作为循环基础数据，然后一条一条的通过该结果集中的数据作为过滤条件到下一个表中查询数据，然后合并结果。如果还有第三个参与 Join，则再通过前两个表的 Join 结果集作为循环基础数据，再一次通过循环查询条件到第三个表中查询数据，如此往复


## 优化

- #### 使用一个自增字段作为主键。
	此场景是针对使用InnoDB存储引擎时. InnoDB使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。
如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。
如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置：此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。
因此，只要可以，请尽量在InnoDB上采用自增字段做主键。
- #### 选择性高的字段建索引
	见上
- #### 最左前缀匹配原则
	非常最重要的原则。mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
	复合索引的情况下，查询条件不包含索引列最左边部分，不会命中复合索引。
- #### 	覆盖索引
	表示直接从辅助索引中就可以得到需要的查询记录，而不需要再从聚簇索引中查询行记录。使用覆盖索引的好处是辅助索引不包含整行记录，所以索引大小会远远小于聚簇索引，单个索引页就可以存储更多的索引项，那么访问索引本身的操作就可以减少顺序IO操作了。对核心SQL可以做覆盖索引
- #### 使用前缀索引
	如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间；

- #### 范围条件查询可以命中索引。
	范围条件有：`<、<=、>、>=、between`等。
	但是范围列后面的列无法用到索引。 索引最多用于一个范围列，如果查询条件中有两个范围列则无法全用到索引：
- #### 索引提示（index hint)
	索引提示（Index Hint），显式地告诉优化器使用哪个索引。mysql优化器有了很大的进步，在绝大部分情况下工作得都非常有效和正确。但这并不意味着就不会出现因为错误地选择了某个索引，而导致SQL语句运行的很慢的情况.
	USE INDEX 只是告诉优化器可以选择该索引，实际上优化器还是会再根据自己的判断进行选择。如果用户确定指定某个索引来完成查询，那么最可靠的是使用 FORCE INDEX ，而不是 USE INDEX 。
- #### Multi-Range Read（MRR）优化
	MRR是 MySQL 5.6 版本时引入的新特性，其作用就是将随机访问转化为较为顺序的访问，以达到减少磁盘的随机访问的目的。MRR并不是每次通过辅助索引就回表去取记录，而是将其rowid给缓存起来，然后对rowid进行排序后，再去访问记录



## 无法使用索引的情况
- #### 索引列上使用表达式或函数
	如：`EXPLAIN SELECT * FROM user WHERE age+1>24;`
- #### 负向条件查询不能使用索引，可以优化为in查询。
	负向条件有：`!=、<>、not in、not exists、not like`等。
- #### 前缀通配符"_" "%"等不能命中索引。
	如： `like '%xxx'`  
- #### 字段类型不匹配
	特别是当字段类型是字符串，一定要将字符常量值用引号引起来。
- #### 用or分割开的条件，
	如果or前的条件中列有索引，而后面的列中没有索引，那么涉及到的索引都不会被用到。
- #### 建立索引的列，不允许为null。
	单列索引不存null值，复合索引不存全为null的值，如果列允许为null，可能会得到“不符合预期”的结果集，所以，请使用not null约束以及默认值。
	`SELECT * FROM user WHERE remark IS NOT NULL;`则不会命中索引