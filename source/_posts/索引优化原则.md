---
title: 索引优化原则
tags:
  - mysql
categories:
  - 数据库
toc: false
date: 2018-03-24 20:42:50
---

Cardinality指标，该值表示索引中唯一值的估计数目，理想情况下该值除以表行数应该尽可能接近1，否则表示该列选择性太低而应该考虑删除该索引。 对Cardinality的统计是使用采样方式进行估算的，当表的修改数目超过总记录的1/16、或者修改总次数超过20亿次，则会随机选择8个数据页重新统计该值，不过通过ANALYZE TABLE命令可以强制让数据库重新收集相关的统计信息。


覆盖索引
表示直接从辅助索引中就可以得到需要的查询记录，而不需要再从聚簇索引中查询行记录。使用覆盖索引的好处是辅助索引不包含整行记录，所以索引大小会远远小于聚簇索引，单个索引页就可以存储更多的索引项，那么访问索引本身的操作就可以减少顺序IO操作了。


## 索引使用的地方和值得优化的地方
1. where
2. order by
	不给order by加索引，就需要mysql server层自己去排序，explain Extra会得到using filesort 当使用排序的空间超过sort_buffer_size的时候，会使用临时表，explain Extra会得到using temporary
3. group by
	group by 操作在没有合适的索引可用的时候，通常先扫描整个表提取数据并创建一个临时表，然后按照group by 指定的列进行排序.在explain中通常可以看到 `using temporary`; `using filesort`
4. join on 多表关联时，要保证关联字段上一定有索引
	通常两表关联，数量少的表为驱动表。从驱动表中取出R1匹配S表所有列，然后R2，R3,直到将R表中的所有数据匹配完，然后合并数据，可以看到这种算法要对S表进行RN次访问，虽然简单，但是相对来说开销还是太大了



- ### 不要过度索引。
	索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。
- ### 更新十分频繁字段上不宜建立索引
	更新会变更 B+ 树，重建索引。这个过程是十分消耗数据库性能的。

- ### 数据区分度不高的字段上不宜建立索引
	区分度可以使用 `count(distinct(列名))/count(*) `来计算。比例越大我们扫描的记录数越少，唯一键的区分度是1
	一般区分度在80%以上的时候就可以建立索引。
	如果返回数据的比例在30%以上(大概)的情况下，优化器不会选择使用索引。
	
- ### 使用短索引
	如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间；
- ### 前导模糊查询不能命中索引。
- ### 数据类型出现隐式转换的时候不会命中索引
	特别是当列类型是字符串，一定要将字符常量值用引号引起来。
- ### 最左前缀匹配原则
	复合索引的情况下，查询条件不包含索引列最左边部分，不会命中复合索引。
- ### 用or分割开的条件，
	如果or前的条件中列有索引，而后面的列中没有索引，那么涉及到的索引都不会被用到。
- ### 负向条件查询不能使用索引，可以优化为in查询。
	负向条件有：!=、<>、not in、not exists、not like等。
- ### 范围条件查询可以命中索引。
	范围条件有：<、<=、>、>=、between等。
	但是范围列后面的列无法用到索引，
	索引最多用于一个范围列，如果查询条件中有两个范围列则无法全用到索引：
- ### 索引列上不能使用表达式或函数
	如：
	`EXPLAIN SELECT * FROM user WHERE age+1>24;`
- ### 建立索引的列，不允许为null。
	单列索引不存null值，复合索引不存全为null的值，如果列允许为null，可能会得到“不符合预期”的结果集，所以，请使用not null约束以及默认值。
	`SELECT * FROM user WHERE remark IS NOT NULL;`则不会命中索引
	


## Explain性能分析