---
title: 索引优化原则
tags:
  - mysql
categories:
  - 数据库
toc: false
date: 2018-03-24 20:42:50
---

 





## 不要过度索引。
我们都知道索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引。

1. 第一种情况是表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引，让查询做全表扫描就好了。至于多少条记录才算多，这个个人有个人的看法，我个人的经验是以2000作为分界线，记录数不超过 2000可以考虑不建索引，超过2000条可以酌情考虑索引。

2. 另一种不建议建索引的情况是索引的选择性较低。所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值：
`count(distinct(列名))/count(*) `
选择性越高的索引价值越大，比例越大我们扫描的记录数越少，唯一键的区分度是1。 一般区分度在80%以上的时候就可以建立索引。如果返回数据的比例在30%以上(大概)的情况下，优化器不会选择使用索引。

- 对Cardinality的统计是使用采样方式进行估算的，当表的修改数目超过总记录的1/16、或者修改总次数超过20亿次，则会随机选择8个数据页重新统计该值，不过通过ANALYZE TABLE命令可以强制让数据库重新收集相关的统计信息。


## 索引使用的地方
1. where
2. order by
	不给order by加索引，就需要mysql server层自己去排序，explain Extra会得到using filesort 当使用排序的空间超过sort_buffer_size的时候，会使用临时表，explain Extra会得到using temporary
3. group by
	group by 操作在没有合适的索引可用的时候，通常先扫描整个表提取数据并创建一个临时表，然后按照group by 指定的列进行排序.在explain中通常可以看到 `using temporary`; `using filesort`
4. join on 多表关联时，要保证关联字段上一定有索引
	通常两表关联，数量少的表为驱动表。从驱动表中取出R1匹配S表所有列，然后R2，R3,直到将R表中的所有数据匹配完，然后合并数据，可以看到这种算法要对S表进行RN次访问，虽然简单，但是相对来说开销还是太大了



## 优化

- #### 使用一个自增字段作为主键。
	此场景是针对使用InnoDB存储引擎时. InnoDB使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。
如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。
这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。
如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置：
此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。
因此，只要可以，请尽量在InnoDB上采用自增字段做主键。

- #### 更新十分频繁字段上不宜建立索引
	更新会变更 B+ 树，重建索引。这个过程是十分消耗数据库性能的。
- #### 	覆盖索引
	表示直接从辅助索引中就可以得到需要的查询记录，而不需要再从聚簇索引中查询行记录。使用覆盖索引的好处是辅助索引不包含整行记录，所以索引大小会远远小于聚簇索引，单个索引页就可以存储更多的索引项，那么访问索引本身的操作就可以减少顺序IO操作了。对核心SQL可以做覆盖索引
- #### 使用短索引
	如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间；
- #### 用or分割开的条件，
	如果or前的条件中列有索引，而后面的列中没有索引，那么涉及到的索引都不会被用到。
- #### 范围条件查询可以命中索引。
	范围条件有：`<、<=、>、>=、between`等。
	但是范围列后面的列无法用到索引。 索引最多用于一个范围列，如果查询条件中有两个范围列则无法全用到索引：

- #### 建立索引的列，不允许为null。
	单列索引不存null值，复合索引不存全为null的值，如果列允许为null，可能会得到“不符合预期”的结果集，所以，请使用not null约束以及默认值。
	`SELECT * FROM user WHERE remark IS NOT NULL;`则不会命中索引



## 无法使用索引的情况
- #### 索引列上使用表达式或函数
	如：`EXPLAIN SELECT * FROM user WHERE age+1>24;`
- #### 负向条件查询不能使用索引，可以优化为in查询。
	负向条件有：`!=、<>、not in、not exists、not like`等。
- #### 最左前缀匹配原则
	复合索引的情况下，查询条件不包含索引列最左边部分，不会命中复合索引。
- #### 前缀通配符"_" "%"等不能命中索引。
	如： `like '%xxx'`  
- #### 字段类型不匹配
	特别是当字段类型是字符串，一定要将字符常量值用引号引起来。

## Explain性能分析