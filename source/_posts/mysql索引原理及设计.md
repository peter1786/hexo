---
title: mysql索引原理及设计
tags:
  - mysql
originContent: >
  # B树


  B-tree: B树（B-Tree 并不是B“减”树，横杠为连接符）又名平衡多路查找树。

  - B-Tree是为磁盘等外存储设备设计的一种平衡查找树。

  - B-Tree结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述B-Tree，首先定义一条记录为一个二元组[key,
  data]，key为记录的键值，对应表中的主键值，data为一行记录中除主键外的数据。对于不同的记录，key值互不相同。（可以以python中的字典中的键值对理解，键唯一且不可改变，就是一个索引的标记，而内容存在data里面）


  一棵m阶的B-Tree有如下特性：

  1. 每个节点最多有m个孩子。

  2. 除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。

  3. 若根节点不是叶子节点，则至少有2个孩子

  4. 所有叶子节点都在同一层，且不包含其它关键字信息

  5. 每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn）

  6. 关键字的个数n满足：ceil(m/2)-1 <= n <= m-1

  7. ki(i=1,…n)为关键字，且关键字升序排序。

  8. Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)


  ![b树1.png](/images/2019/03/20/ccaabea0-4b11-11e9-bf9f-75bbc5f349d9.png)


  **注** 绿色为key, 红色为data, 蓝色为指针

  以根节点为例，里面饮食了两个key为别15和30，P1指针指向的子树的数据范围为小于15，P2指针指向的子树的数据范围为15~30，P3指针指向的子树的数据范围为大于30。




  # B+tree

  B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。

  之前我们记得B-Tree的索引和关键字key-data对存在磁盘里面，然后被磁盘IO操作读入内存，那么在磁盘页中，如果数据很大呢，如果是大数据呢！！！！

  如果数据大的话，磁盘页无法装载，会使得一页的key的数量减少，还是会使得B-Tree的深度增加，这样还是会增加磁盘IO查询，计算机科学的老前辈就有一个大胆的想法，那么我把数据全部放在Tree的叶子节点呢。

  在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。

  B+Tree相对于B-Tree有几点不同：

  非叶子节点只存储键值信息。

  所有叶子节点之间都有一个链指针。

  数据记录都存放在叶子节点中。


  ![b树.png](/images/2019/03/20/e19bc480-4b11-11e9-bf9f-75bbc5f349d9.png)
categories:
  - 数据库
toc: false
date: 2018-03-22 22:33:00
---

一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘 I/O 消耗，相对于内存存取，I/O 存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘 I/O 操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘 I/O 的存取次数。而 B-/+/*Tree，经过改进可以有效的利用系统对磁盘的块读取特性，在读取相同磁盘块的同时，尽可能多的加载索引数据，来提高索引命中效率，从而达到减少磁盘 IO 的读取次数。


# B树

B-tree: B树（B-Tree 并不是B“减”树，横杠为连接符）又名平衡多路查找树。
- B-Tree是为磁盘等外存储设备设计的一种平衡查找树。
- B-Tree结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述B-Tree，首先定义一条记录为一个二元组[key, data]，key为记录的键值，对应表中的主键值，data为一行记录中除主键外的数据。对于不同的记录，key值互不相同。（可以以python中的字典中的键值对理解，键唯一且不可改变，就是一个索引的标记，而内容存在data里面）

一棵m阶的B-Tree有如下特性：
1. 每个节点最多有m个孩子。
2. 除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。
3. 若根节点不是叶子节点，则至少有2个孩子
4. 所有叶子节点都在同一层，且不包含其它关键字信息
5. 所有非叶子结点中包含下列信息数据 (P0 , K1 , P1 , K2 , P2 , … , Kn , Pn )，其中： Ki (i=1,…,n)为关键字，且关键字升序排序 Ki < Ki+1 , Pi (i=0,…,n)为指向子树根结点的指针,指向的子树的所有节点关键字均小于ki但都大于k(i-1)
6. 关键字的个数n满足：ceil(m/2)-1 <= n <= m-1

## 特征
- 关键字集合分布在整颗树中；
- 任何一个关键字出现且只出现在一个结点中；
- 搜索有可能在非叶子结点结束；
- 其搜索性能等价于在关键字全集内做一次二分查找；
- 自动层次控制；

![b树1.png](/images/2019/03/20/ccaabea0-4b11-11e9-bf9f-75bbc5f349d9.png)

**注** 绿色为key, 红色为data, 蓝色为指针
以根节点为例，里面饮食了两个key为别15和30，P1指针指向的子树的数据范围为小于15，P2指针指向的子树的数据范围为15~30，P3指针指向的子树的数据范围为大于30。



从图中可以看出，B-tree 利用了磁盘块的特性进行构建的树。每个磁盘块一个节点，每个节点包含了很关键字。把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度。

B-tree 巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页（每页为 4K），这样每个节点只需要一次 I/O 就可以完全载入。
B-tree 的数据可以存在任何节点中。

# B+tree
B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。
之前我们记得B-Tree的索引和关键字key-data对存在磁盘里面，然后被磁盘IO操作读入内存，那么在磁盘页中，如果数据很大呢，如果是大数据呢！！！！
如果数据大的话，磁盘页无法装载，会使得一页的key的数量减少，还是会使得B-Tree的深度增加，这样还是会增加磁盘IO查询，计算机科学的老前辈就有一个大胆的想法，那么我把数据全部放在Tree的叶子节点呢。
在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。

## B+Tree相对于B-Tree有几点不同：
非叶子节点只存储键值信息。
所有叶子节点之间都有一个链指针。
数据记录都存放在叶子节点中。

![b树.png](/images/2019/03/20/e19bc480-4b11-11e9-bf9f-75bbc5f349d9.png)


B+tree 是 B-tree 的变种，数据只能存储在叶子节点。

B+tree 是 B-tree 的变种，B+tree 数据只存储在叶子节点中。这样在 B 树的基础上每个节点存储的关键字数更多，树的层级更少所以查询数据更快，所有指关键字指针都存在叶子节点，所以每次查找的次数都相同所以查询速度更稳定;

如果每个节点能存放 M 个数据，每个节点的数据在 M/2 到 M 之间。预留出空间可以插入新的数据。


保持树平衡主要是为了提高查询性能，但为了维护树的平衡，成本也是巨大的，当有数据插入或删除时，需采用拆分节点、左旋、右旋等方法。B+树因为其高扇出性，所以具有高平衡性，通常其高度都在2~3层，查询时可以有效减少IO次数。B+树索引可以分为聚集索引(clustered index)和非聚集索引（即辅助索引，secondary index）。

聚集索引：InnoDB表时索引组织表，即表中数据按主键B+树存放，叶子节点直接存放数据，每张表只能有一个聚集索引。
辅助索引：辅助索引（也称非聚集索引）是指叶节点不包含行的全部数据，叶节点除了包含键值之外，还包含一个书签连接，通过该书签再去找相应的行数据。
