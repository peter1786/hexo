---
title: mysql索引原理及设计
tags:
  - mysql
originContent: >-
  我们知道，数据库查询是数据库的最主要功能之一。我们都希望查询数据的速度能尽可能的快。较大程度上的提升是通过索引来做到的，索引可能只有原始数据库的1%大小，但是它可以更快速地被检索避免全表扫描。数据库索引好比是一本书前面的目录，能加快数据库的查询速度。


  但一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘 I/O
  消耗，相对于内存存取，I/O 存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘 I/O
  操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘 I/O 的存取次数。


  典型的二叉查找树结构，其查找的时间复杂度O(log2N)与树的深度相关，那么降低树的深度自然会提高查找效率。那么如何减少树的深度呢，一个基本的想法就是：采用多叉树结构


  # B树

  B-tree: B树（B-Tree 并不是B“减”树，横杠为连接符）又名平衡多路查找树。


  #### 一棵m阶的B-Tree有如下特性：

  1. 每个节点最多有m个孩子。

  2. 除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。

  3. 若根节点不是叶子节点，则至少有2个孩子

  4. 所有叶子节点都在同一层，且不包含其它关键字信息

  5. 所有非叶子结点中包含下列信息数据 (P0 , K1 , P1 , K2 , P2 , … , Kn , Pn )，其中： Ki
  (i=1,…,n)为关键字，且关键字升序排序 Ki < Ki+1 , Pi
  (i=0,…,n)为指向子树根结点的指针,指向的子树的所有节点关键字均小于ki但都大于k(i-1)

  6. 关键字的个数n满足：ceil(m/2)-1 <= n <= m-1


  #### 特征

  - 关键字集合分布在整颗树中；

  - 任何一个关键字出现且只出现在一个结点中；

  - 搜索有可能在非叶子结点结束；

  - 其搜索性能等价于在关键字全集内做一次二分查找；

  - 自动层次控制；


  ![b树1.png](/images/2019/03/20/ccaabea0-4b11-11e9-bf9f-75bbc5f349d9.png)



  以根节点为例，里面包含了两个key为别17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。


  从图中可以看出，B树是利用了磁盘块的特性进行构建的树。每个磁盘块一个节点，每个节点包含了很多关键字。把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度。


  B-tree 的数据可以存在任何节点中。


  # B+tree

  B+Tree是在B树基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。

  之前我们记得B-Tree的索引和关键字key-data对存在磁盘里面，然后被磁盘IO操作读入内存，如果数据大的话，磁盘页无法装载，会使得一页的key的数量减少，还是会使得B-Tree的深度增加，这样还是会增加磁盘IO查询

  在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。


  #### B+Tree相对于B-Tree有几点不同：

  - 数据只存放在叶子节点中，非叶子节点只存储key信息。这样在 B 树的基础上每个节点存储的关键字数更多，降低树的高度，树的层级更少所以查询数据更快

  - 所有叶子节点之间都有一个链指针。做这个优化的目的是为了提高区间访问的性能

  - 


  ![b树.png](/images/2019/03/20/e19bc480-4b11-11e9-bf9f-75bbc5f349d9.png)


  如果每个节点能存放 M 个数据，每个节点的数据在 M/2 到 M 之间。预留出空间可以插入新的数据。



  保持树平衡主要是为了提高查询性能，但为了维护树的平衡，成本也是巨大的，当有数据插入或删除时，需采用拆分节点、左旋、右旋等方法。B+树因为其高扇出性，所以具有高平衡性，通常其高度都在2~3层，查询时可以有效减少IO次数。B+树索引可以分为聚集索引(clustered
  index)和非聚集索引（即辅助索引，secondary index）。


  聚集索引：InnoDB表时索引组织表，即表中数据按主键B+树存放，叶子节点直接存放数据，每张表只能有一个聚集索引。

  辅助索引：辅助索引（也称非聚集索引）是指叶节点不包含行的全部数据，叶节点除了包含键值之外，还包含一个书签连接，通过该书签再去找相应的行数据。



  MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。



  所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。


  这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。



  了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。






  参考： https://zh.wikipedia.org/wiki/B%E6%A0%91
categories:
  - 数据库
toc: false
date: 2018-03-22 22:33:00
---

我们知道，数据库查询是数据库的最主要功能之一。我们都希望查询数据的速度能尽可能的快。较大程度上的提升是通过索引来做到的，索引可能只有原始数据库的1%大小，但是它可以更快速地被检索避免全表扫描。数据库索引好比是一本书前面的目录，能加快数据库的查询速度。

但一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘 I/O 消耗，相对于内存存取，I/O 存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘 I/O 操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘 I/O 的存取次数。

典型的二叉查找树结构，其查找的时间复杂度O(log2N)与树的深度相关，那么降低树的深度自然会提高查找效率。那么如何减少树的深度呢，一个基本的想法就是：采用多叉树结构

# B树
B-tree: B树（B-Tree 并不是B“减”树，横杠为连接符）又名平衡多路查找树。

#### 根据定义，一棵m阶的B-Tree需要同时满足如下条件：
1. 每个节点最多有m个孩子。
2. 除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。
3. 若根节点不是叶子节点，则至少有2个孩子
4. 所有叶子节点都在同一层
5. 所有非叶子结点中包含下列信息数据 (P0 , K1 , P1 , K2 , P2 , … , Kn , Pn )，其中： Ki (i=1,…,n)为关键字，且关键字升序排序 Ki < Ki+1 , Pi (i=0,…,n)为指向子树根结点的指针,指向的子树的所有节点关键字均小于ki但都大于k(i-1)；关键字的个数n满足：ceil(m/2)-1 <= n <= m-1


![b树1.png](/images/2019/03/20/ccaabea0-4b11-11e9-bf9f-75bbc5f349d9.png)

#### 特征
以根节点为例，里面包含了两个key为别17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。

从图中可以看出，B树是利用了磁盘块的特性进行构建的树。每个磁盘块一个节点，每个节点包含了很多关键字。在实际应用中的B树的阶数m都非常大（通常大于100），所以即使存储大量的数据，B树的高度仍然比较小，减少数据查找的次数和复杂度。

一个Ｂ树在它内部节点中存储键值

# B+tree
B+Tree是在B树基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。


#### B+Tree相对于B-Tree有几点不同：
- 所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，非叶子节点只存储key信息。这样在 B 树的基础上每个节点存储的key更多，降低树的高度，树的层级更少所以查询数据更快
- 所有叶子节点之间都有一个链指针。做这个优化的目的是为了提高区间访问的性能
- 所有的叶子结点中包含了全部元素的信息，所有分支节点的关键字都是对应子树中关键字的最大值


![b树.png](/images/2019/03/20/e19bc480-4b11-11e9-bf9f-75bbc5f349d9.png)


B+树索引可以分为聚集索引(clustered index)和非聚集索引（即辅助索引，secondary index）。

1. 聚集索引：InnoDB表主键索引，叶子节点直接存放数据，每张表只能有一个聚集索引。
2. 非聚集索引：非聚集索引是指叶节点不包含行的全部数据，叶节点除了包含键值之外，还包含一个书签连接，通过该书签再去找相应的行数据。

MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。

所以InnoDB要求表必须有主键，如果没有显式指定，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。

聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。

参考： https://zh.wikipedia.org/wiki/B%E6%A0%91