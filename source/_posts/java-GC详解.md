---
title: java GC详解
tags:
  - java
categories:
  - java
toc: false
date: 2018-11-02 15:09:29
---

# 何为GC？
顾名思义,垃圾收集(Garbage Collection)的意思就是 —— 找到垃圾并进行清理。GC是后台的守护进程。它的特别之处是它是一个低优先级进程，但是可以根据内存的使用情况动态的调整他的优先级。因此，它是在内存中低到一定限度时才会自动运行，从而实现对内存的回收。这就是垃圾回收的时间不确定的原因。

为何要这样设计：因为GC也是进程，也要消耗CPU等资源，如果GC执行过于频繁会对java的程序的执行产生较大的影响（java解释器本来就不快），因此JVM的设计者们选着了不定期的gc。


在JVM的五个内存区域中，有3个是不需要进行垃圾回收的：本地方法栈、程序计数器、虚拟机栈。因为他们的生命周期是和线程同步的，随着线程的销毁，他们占用的内存会自动释放。


程序运行期间，几乎所有对象实例存储在运行时数据区域的heap中，当一个对象不再被引用（使用），它就需要被收回。在GC过程中，这些不再被使用的对象从heap中收回，这样就会有空间被循环利用。

# 如何识别垃圾

### ​引用计数法
为每个对象添加一个计数器，当有地方引用该对象时计数器加1，当引用失效时计数器减1。任何引用计数为0的对象可以被当作垃圾收集。

优点：引用计数收集器执行简单，判定效率高，可以保证对象引用为0时立马得到清理，无不确定性。
GC可与应用交替运行，不需要暂停应用即可完成回收功能，实时响应能力比较高


缺点： 不能单独解决循环引用问题,需要辅助其它算法来解决。实现一个高效率的引用计数 GC 比较困难：在增加/减少对象的引用时，修改引用次数需要原子操作（涉及到加锁），同时在减少一个对象的引用计数时，会级联减少其引用对象的计数

采用的语言有：c++/python/php/oc/swift

**补**：除了用在 GC 领域，还广泛用在管理系统资源上。比如：大多数文件系统会维持特定文件/block的引用数（inode里面的link count），这些引用被称为 hard links。当引用数为0时，这个文件就可以被安全的删除了。



### 可达性分析法
通过“GC ROOTs”的对象作为搜索起始点，通过引用向下搜索，所走过的路径称为引用链。通过对象是否有到达引用链的路径来判断对象是否可被回收

![01_03_JavaGCmarkandsweep.png](/images/2019/04/12/6428e500-5cd2-11e9-b3e6-9b6b7bdcccd7.png)


#### 可作为GC ROOTs的对象
1. 虚拟机栈中引用的对象
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中JNI引用的对象


#### 参考
https://www.quora.com/Why-doesnt-Apple-Swift-adopt-the-memory-management-method-of-garbage-collection-like-Java-uses
https://softwareengineering.stackexchange.com/questions/285333/how-does-garbage-collection-compare-to-reference-counting
https://www.quora.com/Why-doesnt-Java-use-reference-counting-based-GC

# 引用类型
JVM中将对象的引用分为了四种类型，不同的对象引用类型会造成GC采用不同的方法进行回收：
1. 强引用：默认情况下，对象采用的均为强引用,GC不会回收其内存
2. 软引用：它用来描述一些可能还有用，但并非必须的对象。在系统内存不够用时，这类引用关联的对象将被垃圾收集器回收。JDK1.2之后提供了SoftReference类来实现软引用。
3. 弱引用：它也是用来描述非须对象的，但它的强度比软引用更弱些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用。
4. 虚引用：最弱的一种引用关系，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的是希望能在这个对象被收集器回收时收到一个系统通知。JDK1.2之后提供了PhantomReference类来实现虚引用。


# GC算法

## 标记对象
参考上面的 **可达性分析**

存活对象在上图中用蓝色表示。而其他对象(上图中灰色的数据结构)就是从GC根元素不可达的, 也就是说程序不能再使用这些不可达的对象(unreachable object)。这样的对象被认为是垃圾, GC会在接下来的阶段中清除他们。

在标记阶段有几个需要注意的点:

在标记阶段,需要暂停所有应用线程, 以遍历所有对象的引用关系。因为不暂停就没法跟踪一直在变化的引用关系图。这种情景叫做 Stop The World pause (全线停顿),而可以安全地暂停线程的点叫做安全点(safe point), 然后, JVM就可以专心执行清理工作。安全点可能有多种因素触发, 当前, GC是触发安全点最常见的原因。

此阶段暂停的时间, 与堆内存大小,对象的总数没有直接关系, 而是由存活对象(alive objects)的数量来决定。所以增加堆内存的大小并不会直接影响标记阶段占用的时间。

标记 阶段完成后, GC进行下一步操作, 删除不可达对象。

## 清除对象
1. Sweep(清除)
Mark and Sweep(标记-清除) 算法的概念非常简单: 直接忽略所有的垃圾。也就是说在标记阶段完成后, 所有不可达对象占用的内存空间, 都被认为是空闲的, 因此可以用来分配新对象。
![03_02_GCsweep.png](/images/2019/04/12/b7c7e350-5d09-11e9-b3e6-9b6b7bdcccd7.png)
**优点**：不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效。
**不足**：（1）标记和清除过程的效率都不高。（这种方法需要使用一个free list空闲列表来记录所有的空闲区域以及大小。对空闲列表的管理会增加分配对象时的工作量）。（2）标记清除后会产生大量不连续的内存碎片。虽然空闲区域的大小是足够的，但却可能没有一个单一区域能够满足这次分配所需的大小，因此本次分配还是会失败（在Java中就是一次OutOfMemoryError）不得不触发另一次垃圾收集动作。


2. Compact(整理)
**标记-清除-整理算法**(Mark-Sweep-Compact), 将所有被标记的对象(存活对象), 迁移到内存空间的起始处, 消除了标记-清除算法的缺点。 
![03_03_GCmarksweepcompact.png](/images/2019/04/12/173eab70-5d0a-11e9-b3e6-9b6b7bdcccd7.png)
**优点**（1）经过整理之后，新对象的分配只需要通过指针碰撞便能完成（Pointer Bumping），相当简单。（2）使用这种方法空闲区域的位置是始终可知的，也不会再有碎片的问题了。
**不足**：GC暂停时间会增加, 因为需要将所有对象复制到另一个地方, 然后修改指向这些对象的引用。

3. Copy(复制)
**标记-复制算法**(Mark and Copy)采用空间换时间的方式来提升性能， 把内存空间划为两个相等的区域，每次只使用其中一个区域。gc时遍历当前使用区域，把正在使用中的对象复制到另外一个区域中.同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。
![03_04_GCmarkandcopyinJava.png](/images/2019/04/12/7219cb60-5d0a-11e9-b3e6-9b6b7bdcccd7.png)
**优点**：（1）标记阶段和复制阶段可以同时进行。（2）每次只对一块内存进行回收，运行高效。（3）只需移动栈顶指针，按顺序分配内存即可，实现简单。（4）内存回收时不用考虑内存碎片的出现（得活动对象所占的内存空间之间没有空闲间隔）。
**不足**：1.内存利用率问题2.在对象存活率较高时，其效率会变低。

复制算法比较适合于新生代（短生存期的对象），在老年代（长生存期的对象）中，对象存活率比较高，如果执行较多的复制操作，效率将会变低，所以老年代一般会选用其他算法，如标记—整理算法。

# 分代GC
分代收集，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，可以将不同生命周期的对象分代，不同的代采取不同的回收算法进行垃圾回收（GC），以便提高回收效率。

![02_03_javaheapedensurvivorold.png](/images/2019/04/12/500ab0f0-5cfd-11e9-b3e6-9b6b7bdcccd7.png)

### Eden 伊甸园
Eden区用来分配新创建的对象(大对象可以直接被创建在年老代）。通常会有多个线程同时创建多个对象, 所以 Eden 区被划分为多个 **线程本地分配缓冲区**(Thread Local Allocation Buffer, 简称TLAB)。通过这种缓冲区划分,大部分对象直接由JVM 在对应线程的TLAB中分配, 避免与其他线程的同步操作。
另一个加快内存分配的技术是bump-the-pointer，通常Eden区是采用是**复制**算法，内容空间是连续的，bump-the-pointer技术的核心就是跟踪最后创建的一个对象，在对象创建时，只需要检查最后一个对象后面是否有足够的内存即可，从而大大加快内存分配速度；

如果 TLAB 中没有足够的内存空间, 就会在共享Eden区(shared Eden space)之中分配。如果共享Eden区也没有足够的空间, 就会触发一次 年轻代GC 来释放内存空间。如果GC之后 Eden 区依然没有足够的空闲内存区域, 则对象就会被分配到老年代空间(Old Generation)。

当 Eden 区进行垃圾收集时, GC将所有从 root 可达的对象过一遍, 并标记为存活对象。

我们曾指出,对象间可能会有跨代的引用, 所以需要一种方法来标记从其他分代中指向Eden的所有引用。这样做又会遭遇各个分代之间一遍又一遍的引用。JVM在实现时采用了一些绝招: 卡片标记(card-marking)。从本质上讲,JVM只需要记住Eden区中 “脏”对象的粗略位置, 可能有老年代的对象引用指向这部分区间。
![02_04_TLABinEdenmemory.png](/images/2019/04/12/6a57a1c0-5cfd-11e9-b3e6-9b6b7bdcccd7.png)

标记阶段完成后, Eden中所有存活的对象都会被复制到存活区(Survivor spaces)里面。整个Eden区就可以被认为是空的, 然后就能用来分配新对象。这种方法称为 “标记-复制”(Mark and Copy): 存活的对象被标记, 然后复制到一个存活区

### Survivor Spaces 存活区
Eden 区的旁边是两个存活区, 称为 from 空间和 to 空间。需要着重强调的的是, 任意时刻总有一个存活区是空的(empty)。

空的那个存活区用于在下一次年轻代GC时存放收集的对象。年轻代中所有的存活对象(包括Edenq区和非空的那个 "from" 存活区)都会被复制到 ”to“ 存活区。GC过程完成后, ”to“ 区有对象,而 'from' 区里没有对象。两者的角色进行正好切换 。

![02_05_howjavagcworks.png](/images/2019/04/12/f8e65010-5cff-11e9-b3e6-9b6b7bdcccd7.png)

存活的对象会在两个存活区之间复制多次, 直到某些对象的存活 时间达到一定的阀值。分代理论假设, 存活超过一定时间的对象很可能会继续存活更长时间。

这类“ 年老” 的对象因此被提升(promoted )到老年代。提升的时候存活区的对象不再是复制到另一个存活区,而是迁移到老年代, 并在老年代一直驻留, 直到变为不可达对象。

为了确定一个对象是否“足够老”, 可以被提升(Promotion)到老年代，GC模块跟踪记录每个存活区对象存活的次数。每次分代GC完成后,存活对象的年龄就会增长。当年龄超过提升阈值(tenuring threshold), 就会被提升到老年代区域。

具体的提升阈值由JVM动态调整,但也可以用参数 -XX:+MaxTenuringThreshold 来指定上限。如果设置 -XX:+MaxTenuringThreshold=0 , 则GC时存活对象不在存活区之间复制，直接提升到老年代。现代 JVM 中这个阈值默认设置为**15个GC周期**。这也是HotSpot中的最大值。

如果存活区空间不够存放年轻代中的存活对象，提升(Promotion)也可能更早地进行。

### 老年代(Old Generation)
对象如果在年轻代存活了足够长的时间而没有被清理掉（即在几次Young GC后存活了下来），则会被复制到年老代。老年代内存空间通常会更大，能存放更多的对象，在年老代上发生的GC次数也比年轻代少。

老年代GC发生的频率比年轻代小很多。同时, 因为预期老年代中的对象大部分是存活的, 所以不再使用标记和复制(Mark and Copy)算法。而是采用移动对象的方式来实现最小化内存碎片。老年代空间的清理算法通常是建立在不同的基础上的。原则上,会执行以下这些步骤	
	
	通过标志位(marked bit),标记所有通过 GC roots 可达的对象.
	删除所有不可达对象
	整理老年代空间中的内容，方法是将所有的存活对象复制,从老年代空间开始的地方,依次存放。

通过上面的描述可知, 老年代GC必须明确地进行整理,以避免内存碎片过多。

### 永久代(PermGen)
在Java 8 之前有一个特殊的空间,称为“永久代”(Permanent Generation)。这是存储元数据(metadata)的地方,比如 class 信息等。此外,这个区域中也保存有其他的数据和信息, 包括 内部化的字符串(internalized strings)等等。实际上这给Java开发者造成了很多麻烦,因为很难去计算这块区域到底需要占用多少内存空间。预测失败导致的结果就是产生 java.lang.OutOfMemoryError: Permgen space 这种形式的错误。除非 ·OutOfMemoryError· 确实是内存泄漏导致的,否则就只能增加 permgen 的大小，例如下面的示例，就是设置 permgen 最大空间为 256 MB:

java -XX:MaxPermSize=256m com.mycompany.MyApplication

### 元数据区(Metaspace)
既然估算元数据所需空间那么复杂, Java 8直接删除了永久代(Permanent Generation)，改用 Metaspace。从此以后, Java 中很多杂七杂八的东西都放置到普通的堆内存里。

当然，像类定义(class definitions)之类的信息会被加载到 Metaspace 中。元数据区位于本地内存(native memory),不再影响到普通的Java对象。默认情况下, Metaspace的大小只受限于 Java进程可用的本地内存。这样程序就不再因为多加载了几个类/JAR包就导致 java.lang.OutOfMemoryError: Permgen space. 。注意, 这种不受限制的空间也不是没有代价的 —— 如果 Metaspace 失控, 则可能会导致很严重的内存交换(swapping), 或者导致本地内存分配失败。

如果需要避免这种最坏情况，那么可以通过下面这样的方式来限制 Metaspace 的大小, 如 256 MB:

java -XX:MaxMetaspaceSize=256m com.mycompany.MyApplication



# Minor GC vs Major GC vs Full GC
### Minor GC
年轻代内存的垃圾收集事件称为Minor GC。当JVM无法为新对象分配内存空间时总会触发 Minor GC,比如 Eden 区占满时。所以(新对象)分配频率越高, Minor GC 的频率就越高。

Minor GC 事件实际上忽略了老年代。从老年代指向年轻代的引用都被认为是GC Root。而从年轻代指向老年代的引用在标记阶段全部被忽略。
与一般的认识相反, Minor GC 每次都会引起全线停顿STW, 暂停所有的应用线程。对大多数程序而言,暂停时长基本上是可以忽略不计的, 因为 Eden 区的对象基本上都是垃圾, 也不怎么复制到存活区/老年代。如果情况不是这样, 大部分新创建的对象不能被垃圾回收清理掉, 则 Minor GC的停顿就会持续更长的时间。

### Major GC vs Full GC
这两个术语并没有正式的定义 —— 无论是在JVM规范还是在GC相关论文中。
依据Minor GC 清理的是年轻代空间(Young space)，相应的:

- Major GC  清理的是老年代空间
- Full GC 清理的是整个堆, 包括年轻代和老年代空间。

很多 Major GC 是由 Full GC 触发的, 所以很多情况下这两者是不可分离的。



三代的特点不同，造就了他们使用的GC算法不同，新生代适合生命周期较短，快速创建和销毁的对象，旧生代适合生命周期较长的对象，持久代在Sun Hotpot虚拟机中就是指方法区（有些JVM根本就没有持久代这一说法）。

Minor collection：
新生代使用将 Eden 还有 Survivor 内的数据利用 semi-space 做复制收集（Copying collection）， 并将原本 Survivor 内经过多次垃圾收集仍然存活的对象移动到 Tenured。

Major collection 则会进行 Minor collection，Tenured 世代则进行标记压缩收集。



# 生存还是死亡
要真正宣告一个对象死亡，至少要经历两次标记过程：
1. 如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法；
2. 当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为没有必要执行；
3. 如果对象要在 finalize() 中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可。 任何一个对象的 finalize() 方法都只会被系统自动调用一次。

这里有两点要注意：
1. 如果一个对象被判定有必要执行 finalize() 方法，那这个对象会先被放置在一个叫做 F-Queue 的队列中，并由虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。这里的 “执行” 指的是虚拟机会触发这个方法，但不会承诺等待它运行结束，原因是：如果一个对象在执行 finalize() 时运行缓慢，或者发生死循环，将很有可能导致 F-Queue 队列中其他对象永久处于等待，甚至整个内存回收系统崩溃。
2. 不鼓励大家使用这种方法来拯救对象。相反，建议大家尽量避免使用它，因为它不是 C/ C++ 中的析构函数，而是 Java 刚诞生时为了使 C/ C++ 程序员更容易接受它所做出的一个妥协。它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。 关闭外部资源，使用 try- finally 或者其他方式都可以做得更好、更及时，所以笔者大家完全可以忘掉 Java 语言中有这个方法的存在。


# 回收方法区
 HotSpot虚拟机对方法区也会执行GC,虽然Java 虚拟机规范中并不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的 “性价” 一般比较低。

永久代的垃圾收集主要回收两部分内容：**废弃常量和无用的类**。

判断一个常量是否是 “废弃常量” 比较简单，而要判定一个类是否是 “无用的类” 的条件则相对苛刻很多。类需要同时满足下面 3 个条件才能算是“无用的类”：
1. 该类所有的实例都已经被回收；
2. 加载该类的 ClassLoader 已经被回收；
3. 该类对应的 java. lang. Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

是否对类进行回收， HotSpot 虚拟机提供了 -Xnoclassgc 参数进行控制，还可以使用 -verbose: class 以及 -XX:+ TraceClassLoading、- XX:+ TraceClassUnLoading 查看类加载和卸载信息。

在大量使用反射、动态代理、 CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。


# GC收集器
Java 8中各种垃圾收集器的组合

| Young | Tenured |JVM options|
|-|-|-|
| Incremental | Incremental |-Xincgc|
| **Serial** | **Serial** |-XX:+UseSerialGC|
| Parallel Scavenge | Serial |-XX:+UseParallelGC -XX:-UseParallelOldGC|
| Parallel New	 | Serial |N/A|
| Serial | Parallel Old |N/A|
| **Parallel Scavenge** | **Parallel Old** |-XX:+UseParallelGC -XX:+UseParallelOldGC|
| Parallel New | Parallel Old |N/A|
| Serial | CMS |-XX:-UseParNewGC -XX:+UseConcMarkSweepGC
| Parallel Scavenge | CMS | -N/A
| **Parallel New** | **CMS** | -XX:+UseParNewGC -XX:+UseConcMarkSweepGC |
| **G1** | **G1** |--XX:+UseG1GC|

除了黑体字表示四种组合外，其余的要么是被废弃, 要么是不支持或者是不太适用于生产环境。


### Serial GC
​Serial GC是最古老也是最基本的收集器，但是现在依然广泛使用，JAVA SE5和JAVA SE6中客户端虚拟机采用的默认配置。

Serial GC 对年轻代使用 **mark-copy(标记-复制)** 算法, 对老年代使用 **mark-sweep-compact(标记-清除-整理)** 算法. 两者都是单线程的垃圾收集器,不能进行并行处理。都会触发全线暂停(STW)，停止所有的应用线程。
![serial.png](/images/2019/04/21/70162010-6445-11e9-b0da-8187301faa2d.png)
该收集器适用于单CPU、新生代空间较小且对暂停时间要求不是特别高的应用上

### Parallel GC
在年轻代使用 标记-复制(mark-copy)算法, 在老年代使用 标记-清除-整理(mark-sweep-compact)算法。年轻代和老年代的垃圾回收都会触发STW事件,暂停所有的应用线程来执行垃圾收集。两者在执行 标记和 复制/整理阶段时都使用多个线程, 因此得名“(Parallel)”。通过并行执行, 使得GC时间大幅减少。

并行垃圾收集器适用于多核服务器,主要目标是增加吞吐量。
![parallelold.png](/images/2019/04/21/c69ba180-6445-11e9-b0da-8187301faa2d.png)

##  CMS (Concurrent Mark and Sweep)

该收集器的目标是解决Serial  GC停顿的问题，以达到最短回收时间。其对年轻代采用并行STW方式的 **mark-copy** (标记-复制)算法, 对老年代主要使用并发 **mark-sweep** (标记-清除)算法。
CMS的设计目标是避免在老年代垃圾收集时出现长时间的卡顿。主要通过两种手段来达成此目标。
- 第一, 不对老年代进行整理, 而是使用空闲列表(free-lists)来管理内存空间的回收。
- 第二, 在 mark-and-sweep (标记-清除) 阶段的大部分工作和应用线程一起并发执行。

在这些阶段并没有明显的应用线程暂停。但值得注意的是, 它仍然和应用线程争抢CPU时间。默认情况下, CMS 使用的并发线程数等于CPU内核数的 1/4。

CMS收集的执行过程是：初始标记(CMS-initial-mark) -> 并发标记(CMS-concurrent-mark) -->并发预清理(CMS-concurrent-preclean)-->可控预清理(CMS-concurrent-abortable-preclean)-> 重新标记(CMS-remark) -> 并发清除(CMS-concurrent-sweep) ->并发重设状态等待下次CMS的触发(CMS-concurrent-reset)

**阶段一：Initial Mark(初始标记)**。 此阶段的目标是标记老年代中所有存活的对象, 包括 GC ROOR 的直接引用, 以及由年轻代中存活对象所引用的对象。 后者也非常重要, 因为老年代是独立进行回收的。
![04_06_g106.png](/images/2019/04/13/a6666530-5dab-11e9-94d6-37a08b4dce14.png)

**阶段二: Concurrent Mark(并发标记)**. 在此阶段, 垃圾收集器遍历老年代, 标记所有的存活对象, 从前一阶段 “Initial Mark” 找到的 root 根开始算起。 顾名思义, “并发标记”阶段, 就是与应用程序同时运行,不用暂停的阶段。 请注意, 并非所有老年代中存活的对象都在此阶段被标记, 因为在标记过程中对象的引用关系还在发生变化。

![04_07_g107.png](/images/2019/04/13/49049030-5df4-11e9-94d6-37a08b4dce14.png)

在上面的示意图中, “Current object” 旁边的一个引用被标记线程并发删除了。

**阶段三**: **Concurrent Preclean**(并发预清理). 此阶段同样是与应用线程并行执行的, 不需要停止应用线程。 因为前一阶段是与程序并发进行的,可能有一些引用已经改变。如果在并发标记过程中发生了引用关系变化,JVM会(通过“Card”)将发生了改变的区域标记为“脏”区(这就是所谓的卡片标记,Card Marking)。
![04_08_g108.png](/images/2019/04/13/cc418480-5df4-11e9-94d6-37a08b4dce14.png)
在预清理阶段,这些脏对象会被统计出来,从他们可达的对象也被标记下来。此阶段完成后, 用以标记的 card 也就被清空了。
![04_09_g109.png](/images/2019/04/13/e3f44270-5df4-11e9-94d6-37a08b4dce14.png)

**阶段四**: **Concurrent Abortable Preclean**(并发可取消的预清理). 此阶段也不停止应用线程. 本阶段尝试在 STW 的 Final Remark 之前尽可能地多做一些工作。本阶段的具体时间取决于多种因素, 因为它循环做同样的事情,直到满足某个退出条件( 如迭代次数, 有用工作量, 消耗的系统时间,等等)。

**阶段五**: **Final Remark(最终标记)**
这是此次GC事件中第二次(也是最后一次)STW阶段。本阶段的目标是完成老年代中所有存活对象的标记. 因为之前的 preclean 阶段是并发的, 有可能无法跟上应用程序的变化速度。所以需要 STW暂停来处理复杂情况。

通常CMS会尝试在年轻代尽可能空的情况运行 final remark 阶段, 以免接连多次发生 STW 事件。

在5个标记阶段完成之后, 老年代中所有的存活对象都被标记了, 现在GC将清除所有不使用的对象来回收老年代空间:

**阶段六**: **Concurrent Sweep**(并发清除). 此阶段与应用程序并发执行,不需要STW停顿。目的是删除未使用的对象,并收回他们占用的空间。
![04_10_g110.png](/images/2019/04/13/572c9120-5df5-11e9-94d6-37a08b4dce14.png)

**阶段七**: **Concurrent Reset**(并发重置). 此阶段与应用程序并发执行,重置CMS算法相关的内部数据, 为下一次GC循环做准备。


CMS收集器的优点：并发收集、低停顿，但远没有达到完美；
CMS收集器的缺点：
- CMS收集器对CPU资源非常敏感，在并发阶段虽然不会导致用户停顿，但是会占用CPU资源而导致应用程序变慢，总吞吐量下降。
- CMS收集器无法处理浮动垃圾，可能出现“Concurrnet Mode Failure”，失败而导致另一次的Full GC。
- CMS收集器对老年代是基于mark-sweep算法的实现，因此也会产生碎片。


##  G1收集器
G1最主要的设计目标是: 将STW停顿的时间和分布变成可预期以及可配置的。事实上, G1是一款软实时垃圾收集器, 也就是说可以为其设置某项特定的性能指标. 可以指定: 在任意 xx 毫秒的时间范围内, STW停顿不得超过 x 毫秒。 如: 任意1秒暂停时间不得超过5毫秒. Garbage-First GC 会尽力达成这个目标(有很大的概率会满足, 但并不完全确定,具体是多少将是硬实时的[hard real-time])。

G1 GC 是一个压缩收集器，它基于回收最大量的垃圾原理进行设计。G1 GC 利用递增、并行、独占暂停这些属性，通过拷贝方式完成压缩目标。此外，它也借助并行、多阶段并行标记这些方式来帮助减少标记、重标记、清除暂停的停顿时间，让停顿时间最小化是它的设计目标之一。

为了达成这项指标, G1 有一些独特的实现。首先, 堆不再分成连续的年轻代和老年代空间。而是划分为多个(通常是2048个)可以存放对象的 小堆区(smaller heap regions)。每个小堆区都可能是 Eden区, Survivor区或者Old区. 每个 Region 都有一个关联的 Remembered Set（简称 RS），RS 的数据结构是 Hash 表，里面的数据是 Card Table （堆中每 512byte 映射在 card table 1byte）。在逻辑上, 所有的Eden区和Survivor区合起来就是年轻代, 所有的Old区拼在一起那就是老年代:
![04_11_g1011.png](/images/2019/04/14/4c74ddb0-5e76-11e9-9e00-0598c74bdc4f.png)

简单的说 RS 里面存在的是 Region 中存活对象的指针。当 Region 中数据发生变化时，首先反映到 Card Table 中的一个或多个 Card 上，RS 通过扫描内部的 Card Table 得知 Region 中内存使用情况和存活对象。在使用 Region 过程中，如果 Region 被填满了，分配内存的线程会重新选择一个新的 Region，空闲 Region 被组织到一个基于链表的数据结构（LinkedList）里面，这样可以快速找到新的 Region。
这样的划分使得 GC不必每次都去收集整个堆空间, 而是以增量的方式来处理: 每次只处理一部分小堆区,称为此次的回收集(collection set). 每次暂停都会收集所有年轻代的小堆区, 但可能只包含一部分老年代小堆区:
![04_12_g102.png](/images/2019/04/14/52f0dea0-5e76-11e9-9e00-0598c74bdc4f.png)



G1的另一项创新, 是在并发阶段估算每个小堆区存活对象的总数。用来构建回收集(collection set)的原则是: 垃圾最多的小堆区会被优先收集。这也是G1名称的由来: garbage-first。



G1收集器有以下特点：
- 并行性：G1 在回收期间，可以有多个 GC 线程同时工作，有效利用多核计算能力；
- 并发性：G1 拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况；
- 分代 GC：G1 依然是一个分代收集器，但是和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；
- 空间整理：G1收集器采用标记-整理算法，不会产生内存空间碎片。分配大对象（直接进Humongous区，专门存放短期巨型对象，不用直接进老年代，避免Full GC的大量开销）不会因为无法找到连续空间而提前触发下一次GC。（年青代拷贝、老年代转移对象无空闲分区、巨型对象无连续分区时触发Full GC，开销极大应该避免）
- 可预见性：由于分区的原因，G1 可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间内，消耗在垃圾收集上的时间不得超过N毫秒，几乎达到Java实时系统（RTSJ）级的垃圾收集器。

## ZGC
JDK 11中加入的实验性质的GC。ZGC项目需要完成的目标是：无论你开了多大的堆内存，控制Java的垃圾回收时长在10ms以内，绝对不超过10ms
## RTSJ垃圾收集器
​       RTSJ垃圾收集器，用于Java实时编程。