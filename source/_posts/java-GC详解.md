---
title: java GC详解
tags:
  - java
originContent: >-
  # Java GC


  Java garbage collection is an automatic process to manage the runtime memory
  used by programs. By doing it automatic JVM relieves the programmer of the
  overhead of assigning and freeing up memory resources in a program.

  java 与 C语言相比的一个优势是，可以通过自己的JVM自动分配和回收内存空间。


  何为GC？

  垃圾回收机制是由垃圾收集器Garbage Collection
  GC来实现的，GC是后台的守护进程。它的特别之处是它是一个低优先级进程，但是可以根据内存的使用情况动态的调整他的优先级。因此，它是在内存中低到一定限度时才会自动运行，从而实现对内存的回收。这就是垃圾回收的时间不确定的原因。


  为何要这样设计：因为GC也是进程，也要消耗CPU等资源，如果GC执行过于频繁会对java的程序的执行产生较大的影响（java解释器本来就不快），因此JVM的设计者们选着了不定期的gc。


   在JVM的五个内存区域中，有3个是不需要进行垃圾回收的：本地方法栈、程序计数器、虚拟机栈。因为他们的生命周期是和线程同步的，随着线程的销毁，他们占用的内存会自动释放。所以，只有方法区和堆区需要进行垃圾回收，回收的对象就是那些不存在任何引用的对象。


  程序运行期间，所有对象实例存储在运行时数据区域的heap中，当一个对象不再被引用（使用），它就需要被收回。在GC过程中，这些不再被使用的对象从heap中收回，这样就会有空间被循环利用。


  ### 如何识别垃圾，判定对象是否可被回收？


  ​       
  引用计数法：给每个对象添加一个计数器，当有地方引用该对象时计数器加1，当引用失效时计数器减1。用对象计数器是否为0来判断对象是否可被回收。缺点：无法解决循环引用的问题(当两个对象相互引用，但是二者都已经没有作用时)


  ​        根搜索算法：也称可达性分析法，通过“GC
  ROOTs”的对象作为搜索起始点，通过引用向下搜索，所走过的路径称为引用链。通过对象是否有到达引用链的路径来判断对象是否可被回收


  #### 可作为GC ROOTs的对象

  1. 虚拟机栈中引用的对象

  2. 方法区中类静态属性引用的对象

  3. 方法区中常量引用的对象

  4. 本地方法栈中JNI引用的对象



  ![image.png](https://user-gold-cdn.xitu.io/2017/11/23/15fe4efea61665d4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)






  2，Java 中的堆是 GC 收集垃圾的主要区域，GC 分为两种：Minor GC、Full GC ( 或称为 Major GC )。


  ​        Minor GC：新生代（Young Gen）空间不足时触发收集，由于Java
  中的大部分对象通常不需长久存活，新生代是GC收集频繁区域，所以采用复制算法。


  ​        Full GC：老年代（Old Gen
  ）空间不足或元空间达到高水位线执行收集动作，由于存放大对象及长久存活下的对象，占用内存空间大，回收效率低，所以采用标记-清除算法。




  ## 内存分区


  内存主要被分为三块：**新生代（Youn Generation）、旧生代（Old Generation）、持久代（Permanent
  Generation）**。三代的特点不同，造就了他们使用的GC算法不同，新生代适合生命周期较短，快速创建和销毁的对象，旧生代适合生命周期较长的对象，持久代在Sun
  Hotpot虚拟机中就是指方法区（有些JVM根本就没有持久代这一说法）。




  ## GC算法



  按照回收策略划分为：标记-清除算法，标记-整理算法，复制算法。


  ​1.标记-清除算法：分为两阶段“标记”和“清除”。首先标记出哪些对象可被回收，在标记完成之后统一回收所有被标记的对象所占用的内存空间。不足之处：1.无法处理循环引用的问题2.效率不高3.产生大量内存碎片（ps：空间碎片太多可能会导致以后在分配大对象的时候而无法申请到足够的连续内存空间，导致提前触发新一轮gc）

   2.标记-整理算法：分为两阶段“标记”和“整理”。首先标记出哪些对象可被回收，在标记完成后，将对象向一端移动，然后直接清理掉边界以外的内存。

   3.复制算法：把内存空间划为两个相等的区域，每次只使用其中一个区域。gc时遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。不足之处：1.内存利用率问题2.在对象存活率较高时，其效率会变低。



  JVM中将对象的引用分为了四种类型，不同的对象引用类型会造成GC采用不同的方法进行回收：

  （1）强引用：默认情况下，对象采用的均为强引用（GC不会回收）

  （2）软引用：软引用是Java中提供的一种比较适合于缓存场景的应用（只有在内存不够用的情况下才会被GC）

  （3）弱引用：在GC时一定会被GC回收

  （4）虚引用：在GC时一定会被GC回收



  Java 不同的世代使用不同的 GC 算法。


  Minor collection：

  新生代 Young Generation 使用将 Eden 还有 Survivor 内的数据利用 semi-space 做复制收集（Copying
  collection）， 并将原本 Survivor 内经过多次垃圾收集仍然存活的对象移动到 Tenured。


  Major collection 则会进行 Minor collection，Tenured 世代则进行标记压缩收集。



  ## GC收集器



  ### 串行收集器（Serial GC）


  ​       **Serial GC**是最古老也是最基本的收集器，但是现在依然广泛使用，JAVA SE5和JAVA
  SE6中客户端虚拟机采用的默认配置。比较适合于只有一个处理器的系统。在串行处理器中minor和major
  GC过程都是用一个线程进行回收的。它的最大特点是在进行垃圾回收时，需要对所有正在执行的线程暂停（stop the
  world），对于有些应用是难以接受的，但是如果应用的实时性要求不是那么高，只要停顿的时间控制在N毫秒之内，大多数应用还是可以接受的，而且事实上，它并没有让我们失望，几十毫秒的停顿，对于我们客户机是完全可以接受的，该收集器适用于单CPU、新生代空间较小且对暂停时间要求不是特别高的应用上，是client级别的默认GC方式。


  #### 4.2 ParNew GC


  ​       基本和Serial GC一样，但本质区别是加入了多线程机制，提高了效率，这样它就可以被用于服务端上（server），同时它可以与CMS
  GC配合，所以，更加有理由将他用于server端。


  #### 4.3 Parallel Scavenge GC


  ​       在整个扫描和复制过程采用多线程的方式进行，适用于多CPU、对暂停时间要求较短的应用，是server级别的默认GC方式。


  #### 4.4 CMS (Concurrent Mark Sweep)收集器

  ​       该收集器的目标是解决Serial 
  GC停顿的问题，以达到最短回收时间。常见的B/S架构的应用就适合这种收集器，因为其高并发、高响应的特点，CMS是基于标记-清楚算法实现的。


  CMS收集器的优点：并发收集、低停顿，但远没有达到完美；


  CMS收集器的缺点：


  ```

  a.CMS收集器对CPU资源非常敏感，在并发阶段虽然不会导致用户停顿，但是会占用CPU资源而导致应用程序变慢，总吞吐量下降。

  b.CMS收集器无法处理浮动垃圾，可能出现“Concurrnet Mode Failure”，失败而导致另一次的Full GC。

  c.CMS收集器是基于标记-清除算法的实现，因此也会产生碎片。复制代码

  ```


  #### 4.5 G1收集器

  ​       相比CMS收集器有不少改进，首先，基于标记-压缩算法，不会产生内存碎片，其次可以比较精确的控制停顿。


  #### 4.6 Serial Old收集器

  ​       Serial
  Old是Serial收集器的老年代版本，它同样使用一个单线程执行收集，使用“标记-整理”算法。主要使用在Client模式下的虚拟机。


  #### 4.7 Parallel Old收集器

  ​       Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。


  #### 4.8 RTSJ垃圾收集器

  ​       RTSJ垃圾收集器，用于Java实时编程。




  HotSpot 有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC 这三个
  GC 有什么不同呢？请记住以下口令：


  - 如果你想要最小化地使用内存和并行开销，请选 Serial GC；

  - 如果你想要最大化应用程序的吞吐量，请选 Parallel GC；

  - 如果你想要最小化 GC 的中断或停顿时间，请选 CMS GC。
categories:
  - java
toc: false
date: 2018-11-02 15:09:29
---

# Java GC

Java garbage collection is an automatic process to manage the runtime memory used by programs. By doing it automatic JVM relieves the programmer of the overhead of assigning and freeing up memory resources in a program.
java 与 C语言相比的一个优势是，可以通过自己的JVM自动分配和回收内存空间。

何为GC？
垃圾回收机制是由垃圾收集器Garbage Collection GC来实现的，GC是后台的守护进程。它的特别之处是它是一个低优先级进程，但是可以根据内存的使用情况动态的调整他的优先级。因此，它是在内存中低到一定限度时才会自动运行，从而实现对内存的回收。这就是垃圾回收的时间不确定的原因。

为何要这样设计：因为GC也是进程，也要消耗CPU等资源，如果GC执行过于频繁会对java的程序的执行产生较大的影响（java解释器本来就不快），因此JVM的设计者们选着了不定期的gc。


 在JVM的五个内存区域中，有3个是不需要进行垃圾回收的：本地方法栈、程序计数器、虚拟机栈。因为他们的生命周期是和线程同步的，随着线程的销毁，他们占用的内存会自动释放。所以，只有方法区和堆区需要进行垃圾回收，回收的对象就是那些不存在任何引用的对象。


程序运行期间，所有对象实例存储在运行时数据区域的heap中，当一个对象不再被引用（使用），它就需要被收回。在GC过程中，这些不再被使用的对象从heap中收回，这样就会有空间被循环利用。

### 如何识别垃圾，判定对象是否可被回收？

​        引用计数法：给每个对象添加一个计数器，当有地方引用该对象时计数器加1，当引用失效时计数器减1。用对象计数器是否为0来判断对象是否可被回收。缺点：无法解决循环引用的问题(当两个对象相互引用，但是二者都已经没有作用时)

​        根搜索算法：也称可达性分析法，通过“GC ROOTs”的对象作为搜索起始点，通过引用向下搜索，所走过的路径称为引用链。通过对象是否有到达引用链的路径来判断对象是否可被回收

#### 可作为GC ROOTs的对象
1. 虚拟机栈中引用的对象
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中JNI引用的对象


![image.png](https://user-gold-cdn.xitu.io/2017/11/23/15fe4efea61665d4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)





2，Java 中的堆是 GC 收集垃圾的主要区域，GC 分为两种：Minor GC、Full GC ( 或称为 Major GC )。

​        Minor GC：新生代（Young Gen）空间不足时触发收集，由于Java 中的大部分对象通常不需长久存活，新生代是GC收集频繁区域，所以采用复制算法。

​        Full GC：老年代（Old Gen ）空间不足或元空间达到高水位线执行收集动作，由于存放大对象及长久存活下的对象，占用内存空间大，回收效率低，所以采用标记-清除算法。



## 内存分区

内存主要被分为三块：**新生代（Youn Generation）、旧生代（Old Generation）、持久代（Permanent Generation）**。三代的特点不同，造就了他们使用的GC算法不同，新生代适合生命周期较短，快速创建和销毁的对象，旧生代适合生命周期较长的对象，持久代在Sun Hotpot虚拟机中就是指方法区（有些JVM根本就没有持久代这一说法）。



## GC算法


按照回收策略划分为：标记-清除算法，标记-整理算法，复制算法。

​1.标记-清除算法：分为两阶段“标记”和“清除”。首先标记出哪些对象可被回收，在标记完成之后统一回收所有被标记的对象所占用的内存空间。不足之处：1.无法处理循环引用的问题2.效率不高3.产生大量内存碎片（ps：空间碎片太多可能会导致以后在分配大对象的时候而无法申请到足够的连续内存空间，导致提前触发新一轮gc）

 2.标记-整理算法：分为两阶段“标记”和“整理”。首先标记出哪些对象可被回收，在标记完成后，将对象向一端移动，然后直接清理掉边界以外的内存。

 3.复制算法：把内存空间划为两个相等的区域，每次只使用其中一个区域。gc时遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。不足之处：1.内存利用率问题2.在对象存活率较高时，其效率会变低。



JVM中将对象的引用分为了四种类型，不同的对象引用类型会造成GC采用不同的方法进行回收：
（1）强引用：默认情况下，对象采用的均为强引用（GC不会回收）
（2）软引用：软引用是Java中提供的一种比较适合于缓存场景的应用（只有在内存不够用的情况下才会被GC）
（3）弱引用：在GC时一定会被GC回收
（4）虚引用：在GC时一定会被GC回收


Java 不同的世代使用不同的 GC 算法。

Minor collection：
新生代 Young Generation 使用将 Eden 还有 Survivor 内的数据利用 semi-space 做复制收集（Copying collection）， 并将原本 Survivor 内经过多次垃圾收集仍然存活的对象移动到 Tenured。

Major collection 则会进行 Minor collection，Tenured 世代则进行标记压缩收集。


## GC收集器


### 串行收集器（Serial GC）

​       **Serial GC**是最古老也是最基本的收集器，但是现在依然广泛使用，JAVA SE5和JAVA SE6中客户端虚拟机采用的默认配置。比较适合于只有一个处理器的系统。在串行处理器中minor和major GC过程都是用一个线程进行回收的。它的最大特点是在进行垃圾回收时，需要对所有正在执行的线程暂停（stop the world），对于有些应用是难以接受的，但是如果应用的实时性要求不是那么高，只要停顿的时间控制在N毫秒之内，大多数应用还是可以接受的，而且事实上，它并没有让我们失望，几十毫秒的停顿，对于我们客户机是完全可以接受的，该收集器适用于单CPU、新生代空间较小且对暂停时间要求不是特别高的应用上，是client级别的默认GC方式。

#### 4.2 ParNew GC

​       基本和Serial GC一样，但本质区别是加入了多线程机制，提高了效率，这样它就可以被用于服务端上（server），同时它可以与CMS GC配合，所以，更加有理由将他用于server端。

#### 4.3 Parallel Scavenge GC

​       在整个扫描和复制过程采用多线程的方式进行，适用于多CPU、对暂停时间要求较短的应用，是server级别的默认GC方式。

#### 4.4 CMS (Concurrent Mark Sweep)收集器
​       该收集器的目标是解决Serial  GC停顿的问题，以达到最短回收时间。常见的B/S架构的应用就适合这种收集器，因为其高并发、高响应的特点，CMS是基于标记-清楚算法实现的。

CMS收集器的优点：并发收集、低停顿，但远没有达到完美；

CMS收集器的缺点：

```
a.CMS收集器对CPU资源非常敏感，在并发阶段虽然不会导致用户停顿，但是会占用CPU资源而导致应用程序变慢，总吞吐量下降。
b.CMS收集器无法处理浮动垃圾，可能出现“Concurrnet Mode Failure”，失败而导致另一次的Full GC。
c.CMS收集器是基于标记-清除算法的实现，因此也会产生碎片。复制代码
```

#### 4.5 G1收集器
​       相比CMS收集器有不少改进，首先，基于标记-压缩算法，不会产生内存碎片，其次可以比较精确的控制停顿。

#### 4.6 Serial Old收集器
​       Serial Old是Serial收集器的老年代版本，它同样使用一个单线程执行收集，使用“标记-整理”算法。主要使用在Client模式下的虚拟机。

#### 4.7 Parallel Old收集器
​       Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。

#### 4.8 RTSJ垃圾收集器
​       RTSJ垃圾收集器，用于Java实时编程。



HotSpot 有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC 这三个 GC 有什么不同呢？请记住以下口令：

- 如果你想要最小化地使用内存和并行开销，请选 Serial GC；
- 如果你想要最大化应用程序的吞吐量，请选 Parallel GC；
- 如果你想要最小化 GC 的中断或停顿时间，请选 CMS GC。