---
title: 数据库事务详解
tags:
  - mysql
originContent: "# 数据库事务详解\n\n## 事务\n\n举一个常见银行转帐的业务场景：小A要转100块钱给小B, 当中至少包括两个操作：\n\n1. 小A账户减少100元\n2. 小B账户增加100元\n\n假如在执行步骤2的时候由于某些原因失败了，那么小A帐户上100元平白消失，系统就对不上账了。支持事务的数据库管理系统就是要确保以上两个操作（一个“事务”）都能完成，或一起取消；\n\n\n\n- 数据库事务（Database Transaction）是数据库管理系统(DBMS)执行过程中的一个逻辑单位，由一个有限的数据库操作序列（对数据库的读/写）构成。包含有以下两个目的：\n  1. 为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。\n  2. 当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。\n\n当事务被提交给了DBMS，则DBMS需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要回滚，回到事务执行前的状态；同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。\n\n但在现实情况下，失败的风险很高。在一个数据库事务的执行过程中，有可能会遇上事务操作失败、网络问题、系统出错，甚至是硬件问题等情况。这便需要DBMS对一个执行失败的事务执行恢复操作，将其数据库状态恢复到一致状态（数据的一致性得到保证的状态）。\n\n\n\n## 事务的四大性质ACID\n\n- **原子性（Atomicity）**\n\n  > 事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。\n\n  想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行**回滚**，而在 MySQL 中，恢复机制是通过*回滚日志*（undo log）实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后在对数据库中的对应行进行写入。这个过程其实非常好理解，为了能够在发生错误时撤销之前的全部操作，肯定是需要将之前的操作都记录下来的，这样在发生错误时才可以回滚。\n\n- **一致性（Consistency）**\n\n  > 事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束\n\n  这个听起来不是很好理解，感觉跟`原子性`有点说不清楚的关系。首先事务的一致性并不是应用程序想要的一致性，例如原本是想往小B帐户上增加100块钱实际确增加了200块钱，这个属于应用程序的责任。\n\n  一致性要求数据库事务必须根据确定的规则（主键约束，外键约束，回滚，触发器等）`合法`的写操作数据。如`主键约束`  要求在一张表内主键必须是唯一的;通过定义外键约束，关系数据库可以保证无法插入无效的数据。\n\n  \n\n- **隔离性（Isolation）**\n\n  > 多个事务并发执行时，一个事务的执行不应影响其他事务的执行\n\n  现实场景中事务经常并发执行，如果没有数据库的事务之间没有隔离性，事务与事务之间就会相互影响，产生级联回滚等问题。如果所有的事务的执行顺序都是线性的，那么对于事务的管理容易得多，但是这样的效率会非常低。如果允许事务的并行执行却能能够提升吞吐量和资源利用率，并且可以减少每个事务的等待时间。\n\n  \n\n  **事务隔离**定义了数据库系统中一个操作的结果在何时以何种方式对其他并发事务操作可见。\n\n  \n\n  所以说数据库的隔离性和一致性其实是一个需要开发者去权衡的问题，为数据库提供什么样的隔离性层级也就决定了数据库的性能以及可以达到什么样的一致性；在 SQL 标准中定义了四种数据库的事务的隔离级别：`READ UNCOMMITED`、`READ COMMITED`、`REPEATABLE READ` 和 `SERIALIZABLE`；\n\n- **持久性（Durability）**\n\n  > 已被提交的事务对数据库的修改应该永久保存在数据库中.即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作\n\n  事务的持久性也是通过日志来实现的，MySQL 使用重做日志（redo log）实现事务的持久性，重做日志由两部分组成，一是内存中的重做日志缓冲区，因为重做日志缓冲区在内存中，所以它是易失的，另一个就是在磁盘上的重做日志文件，它是持久的。当我们在一个事务中尝试对数据进行修改时，它会先将数据从磁盘读入内存，并更新内存中缓存的数据，然后生成一条重做日志并写入重做日志缓存，当事务真正提交时，MySQL 会将重做日志缓存中的内容刷新到重做日志文件，再将内存中的数据更新到磁盘上.在事务提交后，重做日志还能在数据没来得及写会磁盘就宕机时，在下次重新启动后能够成功恢复数据\n\n\n\n\n\n## 事务的隔离级别\n\n| 隔离级别                     | 脏读   | 不可重复读 | 幻读   |\n| ---------------------------- | ------ | ---------- | ------ |\n| 未提交读（Read uncommitted） | 可能   | 可能       | 可能   |\n| 已提交读（Read committed）   | 不可能 | 可能       | 可能   |\n| 可重复读（Repeatable read）  | 不可能 | 不可能     | 可能   |\n| 可串行化（Serializable ）    | 不可能 | 不可能     | 不可能 |\n\n\n\n#### 未提交读 RAED UNCOMMITED\n\n​\t使用查询语句不会加锁，可能会读到未提交的数据（Dirty Read）；\n\n#### 已提交读READ COMMITED\n\n​\t在这个级别中，写锁(write locks)一直保持到事务结束，但是读锁(read locks)在SELECT操作完成后马上释放。这种隔离级别保证了读到的任何数据都是提交的数据，避免读到中间的未提交的数据(dirty reads)。但是不保证事务重新读的时候能读到相同的数据，因为在每次数据读完之后其他事务可以修改刚才读到的数据。\n\n#### 可重复读 REPEATABLE READ\n\n`幻读`的定义：在事务执行过程中，当两个完全相同的查询语句执行得到不同的结果集。通常发生在两次查询中间有别的事务新增或删除数据行导致。在可重复读级别，这个范围不会被锁定，允许记录插入，因此第二次执行语句1的结果中会包括新插入的行。\n\n- innodb在`RR`隔离级别采用的是MVCC多版本并发控制, 快照读读不加锁，当前读会使用next-key锁机制因此不会存在`幻读`的问题。(关于mvcc与next-key锁机制改天单独详解)\n\n#### SERIALIZABLE：\n\n将全部的查询语句加上共享锁\n\n\n\n\n\n大部分的数据库中都使用了 READ COMMITED 作为默认的事务隔离级别，但是 MySQL 使用了 REPEATABLE READ 作为默认配置；\n\n\n\n\n\n### 隔离级别的实现\n\n数据库对于隔离级别的实现就是使用**并发控制机制**对在同一时间执行的事务进行控制，限制不同的事务对于同一资源的访问和更新，而最重要也最常见的并发控制机制，在这里我们将简单介绍三种最重要的并发控制器机制的工作原理。\n\n#### 锁\n\n锁是一种最为常见的并发控制机制，在一个事务中，我们并不会将整个数据库都加锁，而是只会锁住那些需要访问的数据项， MySQL 和常见数据库中的锁都分为两种，共享锁（Shared）和互斥锁（Exclusive），前者也叫读锁，后者叫写锁。\n\n\n\n读锁保证了读操作可以并发执行，相互不会影响，而写锁保证了在更新数据库数据时不会有其他的事务访问或者更改同一条记录造成不可预知的问题。\n\n#### 时间戳\n\n除了锁，另一种实现事务的隔离性的方式就是通过时间戳，使用这种方式实现事务的数据库，例如 PostgreSQL 会为每一条记录保留两个字段；*读时间戳*中包括了所有访问该记录的事务中的最大时间戳，而记录行的*写时间戳*中保存了将记录改到当前值的事务的时间戳。】\n\n\n\n\n\n使用时间戳实现事务的隔离性时，往往都会使用乐观锁，先对数据进行修改，在写回时再去判断当前值，也就是时间戳是否改变过，如果没有改变过，就写入，否则，生成一个新的时间戳并再次更新数据，乐观锁其实并不是真正的锁机制，它只是一种思想，在这里并不会对它进行展开介绍。\n\n#### 多版本和快照隔离\n\n通过维护多个版本的数据，数据库可以允许事务在数据被其他事务更新时对旧版本的数据进行读取，很多数据库都对这一机制进行了实现；因为所有的读操作不再需要等待写锁的释放，所以能够显著地提升读的性能，MySQL 和 PostgreSQL 都对这一机制进行自己的实现，也就是 MVCC，虽然各自实现的方式有所不同，MySQL 就通过文章中提到的回滚日志实现了 MVCC，保证事务并行执行时能够不等待互斥锁的释放直接获取数据。\n\n### 隔离性与原子性\n\n在这里就需要简单提一下在在原子性一节中遇到的级联回滚等问题了，如果一个事务对数据进行了写入，这时就会获取一个互斥锁，其他的事务就想要获得改行数据的读锁就必须等待写锁的释放，自然就不会发生级联回滚等问题了。\n\n\n\n不过在大多数的数据库，比如 MySQL 中都使用了 MVCC 等特性，也就是正常的读方法是不需要获取锁的，在想要对读取的数据进行更新时需要使用 `SELECT ... FOR UPDATE` 尝试获取对应行的互斥锁，以保证不同事务可以正常工作。\n\n\n\n### 隔离级别vs 锁持续时间\n\n\n\n参考：[wikipedia database transaction](https://en.wikipedia.org/wiki/Database_transaction)\n\n[ACID]("
categories:
  - 数据库
toc: false
date: 2019-03-15 20:00:09
---

# 数据库事务详解

## 事务

举一个常见银行转帐的业务场景：小A要转100块钱给小B, 当中至少包括两个操作：

1. 小A账户减少100元
2. 小B账户增加100元

假如在执行步骤2的时候由于某些原因失败了，那么小A帐户上100元平白消失，系统就对不上账了。支持事务的数据库管理系统就是要确保以上两个操作（一个“事务”）都能完成，或一起取消；



- 数据库事务（Database Transaction）是数据库管理系统(DBMS)执行过程中的一个逻辑单位，由一个有限的数据库操作序列（对数据库的读/写）构成。包含有以下两个目的：
  1. 为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。
  2. 当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。

当事务被提交给了DBMS，则DBMS需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要回滚，回到事务执行前的状态；同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。

但在现实情况下，失败的风险很高。在一个数据库事务的执行过程中，有可能会遇上事务操作失败、网络问题、系统出错，甚至是硬件问题等情况。这便需要DBMS对一个执行失败的事务执行恢复操作，将其数据库状态恢复到一致状态（数据的一致性得到保证的状态）。



## 事务的四大性质ACID

- **原子性（Atomicity）**

  > 事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。

  想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行**回滚**，而在 MySQL 中，恢复机制是通过*回滚日志*（undo log）实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后在对数据库中的对应行进行写入。这个过程其实非常好理解，为了能够在发生错误时撤销之前的全部操作，肯定是需要将之前的操作都记录下来的，这样在发生错误时才可以回滚。

- **一致性（Consistency）**

  > 事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束

  这个听起来不是很好理解，感觉跟`原子性`有点说不清楚的关系。首先事务的一致性并不是应用程序想要的一致性，例如原本是想往小B帐户上增加100块钱实际确增加了200块钱，这个属于应用程序的责任。

  一致性要求数据库事务必须根据确定的规则（主键约束，外键约束，回滚，触发器等）`合法`的写操作数据。如`主键约束`  要求在一张表内主键必须是唯一的;通过定义外键约束，关系数据库可以保证无法插入无效的数据。

  

- **隔离性（Isolation）**

  > 多个事务并发执行时，一个事务的执行不应影响其他事务的执行

  现实场景中事务经常并发执行，如果没有数据库的事务之间没有隔离性，事务与事务之间就会相互影响，产生级联回滚等问题。如果所有的事务的执行顺序都是线性的，那么对于事务的管理容易得多，但是这样的效率会非常低。如果允许事务的并行执行却能能够提升吞吐量和资源利用率，并且可以减少每个事务的等待时间。

  

  **事务隔离**定义了数据库系统中一个操作的结果在何时以何种方式对其他并发事务操作可见。

  

  所以说数据库的隔离性和一致性其实是一个需要开发者去权衡的问题，为数据库提供什么样的隔离性层级也就决定了数据库的性能以及可以达到什么样的一致性；在 SQL 标准中定义了四种数据库的事务的隔离级别：`READ UNCOMMITED`、`READ COMMITED`、`REPEATABLE READ` 和 `SERIALIZABLE`；

- **持久性（Durability）**

  > 已被提交的事务对数据库的修改应该永久保存在数据库中.即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作

  事务的持久性也是通过日志来实现的，MySQL 使用重做日志（redo log）实现事务的持久性，重做日志由两部分组成，一是内存中的重做日志缓冲区，因为重做日志缓冲区在内存中，所以它是易失的，另一个就是在磁盘上的重做日志文件，它是持久的。当我们在一个事务中尝试对数据进行修改时，它会先将数据从磁盘读入内存，并更新内存中缓存的数据，然后生成一条重做日志并写入重做日志缓存，当事务真正提交时，MySQL 会将重做日志缓存中的内容刷新到重做日志文件，再将内存中的数据更新到磁盘上.在事务提交后，重做日志还能在数据没来得及写会磁盘就宕机时，在下次重新启动后能够成功恢复数据





## 事务的隔离级别

| 隔离级别                     | 脏读   | 不可重复读 | 幻读   |
| ---------------------------- | ------ | ---------- | ------ |
| 未提交读（Read uncommitted） | 可能   | 可能       | 可能   |
| 已提交读（Read committed）   | 不可能 | 可能       | 可能   |
| 可重复读（Repeatable read）  | 不可能 | 不可能     | 可能   |
| 可串行化（Serializable ）    | 不可能 | 不可能     | 不可能 |



#### 未提交读 RAED UNCOMMITED

​	使用查询语句不会加锁，可能会读到未提交的数据（Dirty Read）；

#### 已提交读READ COMMITED

​	在这个级别中，写锁(write locks)一直保持到事务结束，但是读锁(read locks)在SELECT操作完成后马上释放。这种隔离级别保证了读到的任何数据都是提交的数据，避免读到中间的未提交的数据(dirty reads)。但是不保证事务重新读的时候能读到相同的数据，因为在每次数据读完之后其他事务可以修改刚才读到的数据。

#### 可重复读 REPEATABLE READ

`幻读`的定义：在事务执行过程中，当两个完全相同的查询语句执行得到不同的结果集。通常发生在两次查询中间有别的事务新增或删除数据行导致。在可重复读级别，这个范围不会被锁定，允许记录插入，因此第二次执行语句1的结果中会包括新插入的行。

- innodb在`RR`隔离级别采用的是MVCC多版本并发控制, 快照读读不加锁，当前读会使用next-key锁机制因此不会存在`幻读`的问题。(关于mvcc与next-key锁机制改天单独详解)

#### SERIALIZABLE：

将全部的查询语句加上共享锁





大部分的数据库中都使用了 READ COMMITED 作为默认的事务隔离级别，但是 MySQL 使用了 REPEATABLE READ 作为默认配置；





### 隔离级别的实现

数据库对于隔离级别的实现就是使用**并发控制机制**对在同一时间执行的事务进行控制，限制不同的事务对于同一资源的访问和更新，而最重要也最常见的并发控制机制，在这里我们将简单介绍三种最重要的并发控制器机制的工作原理。

#### 锁

锁是一种最为常见的并发控制机制，在一个事务中，我们并不会将整个数据库都加锁，而是只会锁住那些需要访问的数据项， MySQL 和常见数据库中的锁都分为两种，共享锁（Shared）和互斥锁（Exclusive），前者也叫读锁，后者叫写锁。



读锁保证了读操作可以并发执行，相互不会影响，而写锁保证了在更新数据库数据时不会有其他的事务访问或者更改同一条记录造成不可预知的问题。

#### 时间戳

除了锁，另一种实现事务的隔离性的方式就是通过时间戳，使用这种方式实现事务的数据库，例如 PostgreSQL 会为每一条记录保留两个字段；*读时间戳*中包括了所有访问该记录的事务中的最大时间戳，而记录行的*写时间戳*中保存了将记录改到当前值的事务的时间戳。】





使用时间戳实现事务的隔离性时，往往都会使用乐观锁，先对数据进行修改，在写回时再去判断当前值，也就是时间戳是否改变过，如果没有改变过，就写入，否则，生成一个新的时间戳并再次更新数据，乐观锁其实并不是真正的锁机制，它只是一种思想，在这里并不会对它进行展开介绍。

#### 多版本和快照隔离

通过维护多个版本的数据，数据库可以允许事务在数据被其他事务更新时对旧版本的数据进行读取，很多数据库都对这一机制进行了实现；因为所有的读操作不再需要等待写锁的释放，所以能够显著地提升读的性能，MySQL 和 PostgreSQL 都对这一机制进行自己的实现，也就是 MVCC，虽然各自实现的方式有所不同，MySQL 就通过文章中提到的回滚日志实现了 MVCC，保证事务并行执行时能够不等待互斥锁的释放直接获取数据。

### 隔离性与原子性

在这里就需要简单提一下在在原子性一节中遇到的级联回滚等问题了，如果一个事务对数据进行了写入，这时就会获取一个互斥锁，其他的事务就想要获得改行数据的读锁就必须等待写锁的释放，自然就不会发生级联回滚等问题了。



不过在大多数的数据库，比如 MySQL 中都使用了 MVCC 等特性，也就是正常的读方法是不需要获取锁的，在想要对读取的数据进行更新时需要使用 `SELECT ... FOR UPDATE` 尝试获取对应行的互斥锁，以保证不同事务可以正常工作。



### 隔离级别vs 锁持续时间



参考：[wikipedia database transaction](https://en.wikipedia.org/wiki/Database_transaction)

[ACID](