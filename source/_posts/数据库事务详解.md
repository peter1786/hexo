---
title: 数据库事务详解
tags:
  - mysql
originContent: ''
categories:
  - 数据库
toc: false
date: 2017-03-15 21:03:33
---

## 事务

举一个常见银行转帐的业务场景：小A要转100块钱给小B, 当中至少包括两个操作：

1. 小A账户减少100元
2. 小B账户增加100元

假如在执行步骤2的时候由于某些原因失败了，那么小A帐户上100元平白消失，系统就对不上账了。支持事务的数据库管理系统就是要确保以上两个操作（一个“事务”）都能完成，或一起取消；

数据库事务（Database Transaction）是数据库管理系统(DBMS)执行过程中的一个逻辑单位，由一个有限的数据库操作序列（对数据库的读/写）构成。包含有以下两个目的：
  1. 为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。
  2. 当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。

当事务被提交给了DBMS，则DBMS需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要回滚，回到事务执行前的状态；同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。

但在现实情况下，失败的风险很高。在一个数据库事务的执行过程中，有可能会遇上事务操作失败、网络问题、系统出错，甚至是硬件问题等情况。这便需要DBMS对一个执行失败的事务执行恢复操作，将其数据库状态恢复到一致状态（数据的一致性得到保证的状态）。

## 事务的四大性质ACID

- **原子性（Atomicity）**

  > 事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。

  想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行**回滚**，而在 MySQL 中，恢复机制是通过*回滚日志*（undo log）实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后在对数据库中的对应行进行写入。这个过程其实非常好理解，为了能够在发生错误时撤销之前的全部操作，肯定是需要将之前的操作都记录下来的，这样在发生错误时才可以回滚。

- **一致性（Consistency）**

  > 事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束

  这个听起来不是很好理解，感觉跟`原子性`有点说不清楚的关系。首先事务的一致性并不是应用程序想要的一致性，例如原本是想往小B帐户上增加100块钱实际确增加了200块钱，这个属于应用程序的责任。

  一致性要求数据库事务必须根据确定的规则（主键约束，外键约束，回滚，触发器等）`合法`的写操作数据。如`主键约束`  要求在一张表内主键必须是唯一的;通过定义外键约束，关系数据库可以保证无法插入无效的数据。

  

- **隔离性（Isolation）**

  > 多个事务并发执行时，一个事务的执行不应影响其他事务的执行

  现实场景中事务经常并发执行，如果没有数据库的事务之间没有隔离性，事务与事务之间就会相互影响，产生级联回滚等问题。如果所有的事务的执行顺序都是线性的，那么对于事务的管理容易得多，但是这样的效率会非常低。如果允许事务的并行执行却能能够提升吞吐量和资源利用率，并且可以减少每个事务的等待时间。

  

  **事务隔离**定义了数据库系统中一个操作的结果在何时以何种方式对其他并发事务操作可见。

  

  所以说数据库的隔离性和一致性其实是一个需要开发者去权衡的问题，为数据库提供什么样的隔离性层级也就决定了数据库的性能以及可以达到什么样的一致性；在 SQL 标准中定义了四种数据库的事务的隔离级别：`READ UNCOMMITED`、`READ COMMITED`、`REPEATABLE READ` 和 `SERIALIZABLE`；

- **持久性（Durability）**

  > 已被提交的事务对数据库的修改应该永久保存在数据库中.即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作

  事务的持久性也是通过日志来实现的，MySQL 使用重做日志（redo log）实现事务的持久性，重做日志由两部分组成，一是内存中的重做日志缓冲区，因为重做日志缓冲区在内存中，所以它是易失的，另一个就是在磁盘上的重做日志文件，它是持久的。当我们在一个事务中尝试对数据进行修改时，它会先将数据从磁盘读入内存，并更新内存中缓存的数据，然后生成一条重做日志并写入重做日志缓存，当事务真正提交时，MySQL 会将重做日志缓存中的内容刷新到重做日志文件，再将内存中的数据更新到磁盘上.在事务提交后，重做日志还能在数据没来得及写会磁盘就宕机时，在下次重新启动后能够成功恢复数据


## 事务的隔离级别

| 隔离级别                     | 脏读   | 不可重复读 | 幻读   |
| -------------------------- | ------ | ---------- | ------ |
| 未提交读（Read uncommitted） | 可能   | 可能       | 可能   |
| 已提交读（Read committed）   | 不可能 | 可能       | 可能   |
| 可重复读（Repeatable read）  | 不可能 | 不可能     | 可能   |
| 可串行化（Serializable ）    | 不可能 | 不可能     | 不可能 |



#### 未提交读 RAED UNCOMMITED

​	使用查询语句不会加锁，可能会读到未提交的数据（Dirty Read）；

#### 已提交读READ COMMITED

​	在这个级别中，写锁(write locks)一直保持到事务结束，但是读锁(read locks)在SELECT操作完成后马上释放。这种隔离级别保证了读到的任何数据都是提交的数据，避免读到中间的未提交的数据(dirty reads)。但是不保证事务重新读的时候能读到相同的数据，因为在每次数据读完之后其他事务可以修改刚才读到的数据。

#### 可重复读 REPEATABLE READ

`幻读`的定义：在事务执行过程中，当两个完全相同的查询语句执行得到不同的结果集。通常发生在两次查询中间有别的事务新增或删除数据行导致。在可重复读级别，这个范围不会被锁定，允许记录插入，因此第二次执行查询语句的结果中会包括新插入的行。

- innodb在`RR`隔离级别采用的是MVCC多版本并发控制, 快照读不加锁，当前读会使用next-key锁机制因此不会存在`幻读`的问题。(关于mvcc与next-key锁机制改天单独详解)

#### SERIALIZABLE：

将全部的查询语句加上共享锁





大部分的数据库中都使用了 READ COMMITED 作为默认的事务隔离级别，但是 MySQL 使用了 REPEATABLE READ 作为默认配置；
