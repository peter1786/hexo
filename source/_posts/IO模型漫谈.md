---
title: IO模型漫谈
tags:
  - 并发
  - io
originContent: ''
categories:
  - linux
toc: false
date: 2018-04-01 22:38:49
---


“一切皆文件”， 这句话是linux/unix设计的哲学核心思想。意思是在类unix系统中我们可以把目录、字符设备、块设备、 套接字、进程、线程、管道等都被视为是一个“文件”来进行读写操作。

#### I/O操作通常包含以下两个不同的阶段：
1. 等待数据准备好
2. 从内核向进程复制数据




# linux I/O模型

### 同步阻塞
阻塞式I/O模型可以说是最简单的I/O模型。

应用进程调用recvfrom，然后切换到内核空间中运行，直到数据报到达且被复制到应用进程缓冲区中才返回。我们说进程从调用recvfrom开始到它返回的整段时间内是被阻塞的。recvfrom成功返回后，应用进程开始处理数据报。

### 同步非阻塞
进程把一个套接字设置为非阻塞是指，在等待I/O数据时，进程并不阻塞，如果数据还没准备好，则直接返回一个错误。

在前两次调用recvfrom时由于数据报没准备好，因此内核马上返回一个系统调用错误。第3次调用recvfrom时，数据报已准备好，数据报被复制到应用进程的缓冲区，接着recvfrom成功返回。 
当一个应用进程像这样不断对一个非阻塞描述符循环调用recvfrom时，我们称之为轮询。应用进程会持续轮询内核，以确定某个操作是否就绪。轮询操作会消耗大量的CPU时间。


### I/O复用模型

当我们调用select函数时，将会阻塞于此函数，等待数据报套接字变为可读。当等待的多个套接字中的其中一个或者多个变得可读时，我们调用recvfrom把数据报复制到应用进程缓冲区。 
比较图3与图1，I/O复用模型好像没什么优势，而且应用进程为了获取数据报，还得增加了一个额外的select系统调用。不过I/O复用模型的优势在于可以同时等待多个（而不只是一个）套接字描述符就绪。


### 信号驱动式I/O模型
为了使用该I/O模型，需要开启套接字的信号驱动I/O功能，并通过sigaction系统调用安装一个信号处理函数。sigaction函数立即返回，我们的进程继续工作，即进程没有被阻塞。当数据报准备好时，内核会为该进程产生一个SIGIO信号，这样我们可以在信号处理函数中调用recvfrom读取数据报，也可以在主循环中读取数据报。无论如何处理SIGIO信号，这种模型的优势在于等待数据报到达期间不被阻塞。

### 异步I/O模型
异步I/O模型的工作机制是，启动某个操作，并让内核在整个操作（包括等待数据和将数据从内核复制到用户空间）完成后通知应用进程。

我们调用aio_read函数，告诉内核，当整个I/O操作完成后通知我们。该系统调用立即返回，而在等待I/O完成期间，应用进程不会被阻塞。当I/O完成（包括数据从内样复制到用户进程）后，内核会产生一个信号通知应用进程，应用进程对数据报进行处理。 
异步I/O模型与信号驱动式I/O的区别在于：信号驱动式I/O在数据报准备好时就通知应用进程，应用进程还需要将数据报从内核复制到用户进程缓冲区；而异步I/O模型则是整个操作完成才通知应用进程，应用进程在整个操作期间都不会被阻塞。


# 各种I/O模型的比较


# 类比
有A，B，C，D，E五个人在钓鱼。 
A使用了最古老的鱼竿，所以开始钓鱼后，就一直守着，直接鱼上钩了再拉竿； 
B由于着急想知道有没鱼上钩，所以隔一会就看一次鱼竿看有没鱼上钩，直到看到鱼上钩后，再拉竿； 
C同时使用了N支鱼竿来钩鱼，然后等着，只要有其中一支鱼竿有鱼上钩，就将对应的鱼竿拉起来； 
D的鱼竿比较高级，当有鱼上钩后，会发出警报提示，所以D开始钓鱼后不用一直守着，一旦鱼竿发出警报，D再回来拉竿即可； 
E为了更省事，直接雇个佣人给他钓鱼，当佣人钓起鱼后，再通知E去取鱼即可。
